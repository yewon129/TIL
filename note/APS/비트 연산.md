# 비트 연산

bit : 정보를 구분할 수 있는 최소 단위

byte : 메모리에 위치 구분할 수 있는 최소 단위

| 연산자 |                   연산자의 기능                    |
| :----: | :------------------------------------------------: |
|   &    |     비트단위로 AND 연산을 한다. (둘다 1이면 1)     |
|        |                  예 ) num1 & num2                  |
|   \|   |   비트단위로 OR 연산을 한다.  (하나라도 1이면 1)   |
|        |                  예) num1 \| num2                  |
|   ^    |  비트단위로 XOR 연산을 한다. ( 같으면 0 다르면 1)  |
|        |                  예) num1 ^ num2                   |
|   ~    | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. |
|        |                      예) ~num                      |
|   <<   |     피연산자의 비트 열을 왼쪽으로 이동시킨다.      |
|        |              예) num << 2 : num * 2^2              |
|   >>   |     피연산자의 비트 열을 오른쪽으로 이동시킨다     |
|        |              예) num >> 2 : num / 2^2              |

* 비트 검사 : 자리가 1인지 0인지 알고 싶어 => & 연산자 사용
* 비트 클리어 : 특정 비트를 0으로 만들기 => & 연산자 사용

* 비트 셋 : 특정 비트를 1로 만들기 => | 연산자 사용
* 특정 비트가 같은지 검사 => ^ 연산자 사용
* 비트 토글 : 반대로 뒤집기 => ^ 연산자 사용

* 비트 반전 => ~ 연산자 사용
* b1, b2, b5가 1인 값
  * a|= 1<< 1 | 1 << 4 | 1<<5

* a, b3 클리어  : 11110111
  * a &= ~(1<<3)
* a의 b3, b5 클리어
  * a &= ~(1<<3 | 1<<5)

* 4 bytes == 32 bits

  * 3번 byte를 1번 byte로 옮기기 : >> 연산자 사용

* 1 << n:

  * 2^n 값을 갖는다
  * 원소가  n 개일 경우 모든 부분집합의 수 의미
  * Power set (모든 부분 집합)
    * 공집합과 자기 자신을 포함한 모든 부분집합
    * 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.

* i & (1<<j)

  * 계산 결과는 i의 j번째 비트가 i인지 아닌지를 의미한다.

  * ```python
    for j in range(8):
        if i & (1<<j):
    ```



##### 비트 연산 예제

```python
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1<<j) else "0"
    print(output)

for i in range(-5, 6):
    print("%3d = " % i, end='')
    Bbit_print(i)
```

```python
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1<<j) else "0"
    print(output, end=' ')
a = 0x10
x = 0x01020304
print("%d = " % a, end = '')
Bbit_print(a)
print()
print("0%X = " % x, end = '')
for i in range(0, 4):
    Bbit_print((x >> i*8) & 0xff)
```

##### 엔디안(Endianness)

* 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다
* 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바르게 이해하지 않으면 오류를 발생시킨다.
* 엔디안 종류
  * 빅 엔디안 ( Big-endian )
    * 보통 긑 단위가 앞에 나온다. 네트워크
  * 리틀 엔디안 ( Little-endian )
    * 작은 단위가 앞에 나온다. 대다수 데스크탑 컴퓨터

```python
# 엔디안 확인 코드
import sys
print(sys.byteorder)
```



##### 비트 연산 예제3

바이트 순서 뒤집기

```python
def ce(n) : # change endian
    p = []
    for i in range(0, 4):
        p.append((n >> (24 - i*8)) & 0xff)
    return p
```

```python
x = 0x01020304
p = []
for i in range(0, 4):
    p.append((x >> (i*8)) & 0xff)

print("x = %d%d%d%d " % (p[0], p[1], p[2], p[3]))
p = ce(x)
print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
```

##### 비트 연산 예제4

```python
def ce1(n):
    return (n << 24 & 0xff000000) | (n << 8 & 0xff0000) | (n >> 8 & 0xff00)| (n >> 24 & 0xff)
# 0x04 0000 0000 0000
# 0x02 0x03 0000 0000
# 0000 0000 0x02 0000
# 0000 0000 0000 0x01
# 결과 : 0x04 0x03 0x02 0x01
```

##### 비트 연산 예제 5

* 비트 연산자 ^를 두번 연산하면 처음 값을 반환한다.

```python
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1<<j) else "0"
    print(output)

a = 0x86
key = 0xAA

print("a ==> ", end = '')
Bbit_print(a)

print("a^=key ==>", end='')
a ^= key;
Bbit_print(a)

print("a^=key ==>", end='')
a^= key;
Bbit_print(a)
```



![image-20220323124735910](C:/Users/sky25/AppData/Roaming/Typora/typora-user-images/image-20220323124735910.png)

### 진수

* 2진수, 8진수, 10진수, 16진수
* 10진수 => 타진수로 변환
  * 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다
  * (149)10 = (10010101)2 = (225)8 = (95)16
* 타진수 => 10진수로 변환
  * (135)8 = 1*8^2 + 3 * 8 + 5*1 = (93)10
  * 소수점이 있을 때
    * (135.12)8 = 1*8^2 + 3*8^1 + 8 + 1* 8(-1) + 2*8^(-2)
* 컴퓨터에서 음의 정수 표현 방법
  * 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환
    * -6 : 1000000000000110 : 부호와 절대값 표현
    * -6 : 1111111111111001 : 1의 보수 표현
  * 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
    * -6 : 1111111111111010 : 2의 보수 표현



### 실수

* 소수점 이하 4자리를 10진수로 나타내면

  ![image-20220323145958382](C:/Users/sky25/AppData/Roaming/Typora/typora-user-images/image-20220323145958382.png)

* 2진 실수를 10진수로 변환하는 방법

![image-20220323150150391](C:/Users/sky25/AppData/Roaming/Typora/typora-user-images/image-20220323150150391.png)

* 실수의 표현
  * 컴퓨터는 실수를 표현하기 위해 부동 소수점 표기법 사용
  * 1001.0011 -> 1.10010011 * 2^3
* 실수를 저장하기 위한 형식  (IEEE754)
  * 단정도 실수 (32비트)
    * 부호1비트 | 지수8비트 | 가수23비트
  * 배정도 실수 (64비트)
    * 부호1비트 | 지수 11비트 | 가수 52비트
  * 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
  * 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것

* 단정도 실수의 가수 부분을 만드는 방법
  * 1001.0011
    * 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트
      * 0001.0010011
    * 소수점 이하를 23비트로 만든다
      * 0001.00100110000000000000000
    * 소수점 이하만을 가수부분에 저장
      * 00100110000000000000000
    * 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소
      * 1.0010011 * 2^3
* 단정도 실수의 지수 부분을 만드는 방법
  * 지수부에는 8비트가 배정
  * 숫자로는 0-255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 익세스 표현법을 사용
    * 익세스 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현
    * 단정도 표현에서의 지수부 익세스 표현

![image-20220323150934147](C:/Users/sky25/AppData/Roaming/Typora/typora-user-images/image-20220323150934147.png)



* 컴퓨터는 실수를 근사적으로 표현한다.
* 실수 자료형의 유효자릿수를 알아두자
  * 32비트 실수형 유효자릿수(십진수) : 6
  * 64비트 실수형 유효자릿수(십진수) : 15

* 파이썬에서의 실수 표현 범위를 알아보자
  * 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넒은 범위 실수 표현할 수 있다.
  * 최대 : 1.*10^308, 이 이상은 inf
  * 최소 : 5.0 * 10^(-324)